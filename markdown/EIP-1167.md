# EIP-1167: What, Why and How?

https://eips.ethereum.org/EIPS/eip-1167

> To simply and cheaply clone contract functionality in an immutable way, this standard specifies a minimal bytecode implementation that delegates all calls to a known, fixed address.

The Factory Pattern often suffers from high gas costs due to the `CREATE` opcode, since each deployment replicates the full contract bytecode. EIP-1167 (Minimal Proxy) solves this by introducing ultra-lightweight proxy contracts that delegate all logic to a single implementation.

Instead of deploying full contracts each time, the factory now deploys tiny proxy clones that forward calls via `DELEGATECALL`.

## Technicalities

EIP-1167 is a specification for how a system has to behave to adhere to the standard.

> A minimal proxy must behave like this, and must have this runtime bytecode layout so that every client/wallet/compiler knows what to expect.

**Bytecode:** 363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3

**In solidity terms:**

```solidity
function () external payable {
    assembly {
        let impl := 0xbebebebebebebebebebebebebebebebebebebebe
        calldatacopy(0, 0, calldatasize())
        let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
        returndatacopy(0, 0, returndatasize())
        switch result
        case 0 { revert(0, returndatasize()) }
        default { return(0, returndatasize()) }
    }
}
```

> You can interleave Solidity statements with inline assembly in a language close to the one of the Ethereum Virtual Machine. This gives you more fine-grained control, which is especially useful when you are enhancing the language by writing libraries or optimizing gas usage.
> https://docs.soliditylang.org/en/latest/assembly.html

The assembly block contains _Yul assembly_, a human'readable assembly for the EVM.

## Implementations

### ğŸ“œ Open Zeppelin's ERC-1167 Brief
